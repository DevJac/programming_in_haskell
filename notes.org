* GHCI
** :set examples
*** :set -Wno-type-defaults
Disables type default warnings.
*** :show
Lists set options and flags.
*** :show modules
List loaded modules.
*** :set +m
Set smart multi-line mode.
*** :set +t
Display the type(s) of every statement.
*** :set +s
Display timing and memory usage statistics after every statement.
** : commands
*** :! command
Run a command outside of GHCI.
*** :{ ... :} multi-line syntax
:{ and :} are the multi-line tags. You might also use :set +m to enable smart multi-line mode.
*** :edit <file>
Opens the file in the configured editor. If file is omitted, it will open the most recently loaded module.
*** :browse <module>
Lists identifiers exported by the given module.
*** :load[!] [*]<module> / :reload[!]
Loads a module or filename, and forgets all previously loaded modules. If not given a module or filename, all modules will be forgotten.

The * option forces the module to be loaded as byte-code.

The ! option turns type errors into warnings, thus allowing you to work on partially complete modules.

:reload reloads the last :loaded module, and also supports the ! option.
*** :main <args> / :run <args>
Runs the main function with the given command line args.
*** :type <expression>
Show the type of the given expression.
*** :info[!] <name>
Displays information about the given name. The ! option will give additional information.

This is useful for finding the fixity of operators.
** it variable
The it variable contains the result of the last expression.
** .ghci file
When GHCI starts, it will run commands in the ./.ghci file, $HOME/.ghc/ghci.conf, and $HOME/.ghci files. These files can be used to set commonly used settings and flags automatically.
* Notes
** functional vs imperative programming
Functional programming is a *style* of programming in which the *application of functions* is fundamental. A functional programming language is a programming language that encourages that *style*.

Imperative programming is a *style* of programming in which *storing and changing values* is fundamental. An imperative programming language is a programming language that encourages that *style*.
*** Example
How would you sum the list of integers from 1 to 100?

Using a functional style, you might call a function to create the list, and then apply another function to sum the elements of that list.

Using an imperative style, you might create a couple variables (like step and total) and then use a loop to step one variable from 1 to 100 while keeping a running total in another variable.
** pattern matching and guards
Guards are something I haven't used much. I wasn't 100% comfortable with how they interacted with pattern matching. I created this odd function to demonstrate their interaction:

foo [1, a, b] | a > b     = True
              | otherwise = False
foo [2, a, b] | a < b     = True
              | otherwise = False
foo _ = False
** list comprehensions
List comprehensions are something I haven't used much. Here is a good example:

pythagoreanTriples n = [ (a, b, c) | a <- [1..n], b <- [a..n], c <- [b..n], a^2 + b^2 == c^2 ]

a <- [1..n] is an example of a generator.

a^2 + b^2 == c^2 is an example of a guard.

Note that generator variables can be used in later generators and guards.

The generators behave like nested loops, with the latter generators "iterating faster" than the earlier generators.
** recursion
A general tip for recursive functions: Identify a "base case" and a "recursive case"; the recursive call (of the recursive case) should move ever closer to the base case, and the base case should end the recursion.

There may be multiple base cases. To find base cases, start listing conditions where you already know the answer. It's OK to have extra bases cases, but you may want to eventually remove extra bases cases for clarity. The more base cases you have, the more targets you have to move your recursive calls towards.

First, make a recursive function work for a specific case (or a specific type); try the simplest case. Afterwards, it might be worthwhile it generalize the function.

"Defining recursive functions is like riding a bicycle: it looks easy when someone else is doing it, may seem impossible when you first try to do it yourself, but becomes simple and natural with practice."
** folds
foldr or "fold right" can be thought of as folding a function from right to left over a list, or as replacing all the cons in a list with a right associative operation. Likewise for foldl or "fold left".

Remember that cons (:) is right associative, and thus foldr is a corollary to lists.

foldr and foldl are easily swapped for associative operations. The difference between the two is most prominent for non-associative operations.
** parameterized types
Type declarations can be parameterized:

type Assoc k v = [(k, v)]

Data declarations can be parameterized:

data List a = Nil | Cons a (List a)
* Project Ideas
** Solve substitution ciphers
This should be possible using letter frequencies and a dictionary.
** Visualize sorting algorithms
Once I've finished my raylib bindings, use it to visualize different sorting algorithms.
** Runoff voting
Implement the runoff voting algorithm and compare with the implementation in chapter 7.
** Balanced tree
Maybe even a red-black tree? I've heard they're difficult to implement.
** Tautology checker
After I learn a parsing library, implement a tautology checker which can parse nicely formatted propositions and determine if they are tautologies.
