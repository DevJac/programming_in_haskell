* GHCI
** :set examples
*** :set -Wno-type-defaults
Disables type default warnings.
*** :show
Lists set options and flags.
*** :show modules
List loaded modules.
*** :set +m
Set smart multi-line mode.
*** :set +t
Display the type(s) of every statement.
*** :set +s
Display timing and memory usage statistics after every statement.
** : commands
*** :! command
Run a command outside of GHCI.
*** :{ ... :} multi-line syntax
:{ and :} are the multi-line tags. You might also use :set +m to enable smart multi-line mode.
*** :edit <file>
Opens the file in the configured editor. If file is omitted, it will open the most recently loaded module.
*** :browse <module>
Lists identifiers exported by the given module.
*** :load[!] [*]<module> / :reload[!]
Loads a module or filename, and forgets all previously loaded modules. If not given a module or filename, all modules will be forgotten.

The * option forces the module to be loaded as byte-code.

The ! option turns type errors into warnings, thus allowing you to work on partially complete modules.

:reload reloads the last :loaded module, and also supports the ! option.
*** :main <args> / :run <args>
Runs the main function with the given command line args.
*** :type <expression>
Show the type of the given expression.
** it variable
The it variable contains the result of the last expression.
** .ghci file
When GHCI starts, it will run commands in the ./.ghci file, $HOME/.ghc/ghci.conf, and $HOME/.ghci files. These files can be used to set commonly used settings and flags automatically.
* Notes
** functional vs imperative programming
Functional programming is a *style* of programming in which the *application of functions* is fundamental. A functional programming language is a programming language that encourages that *style*.

Imperative programming is a *style* of programming in which *storing and changing values* is fundamental. An imperative programming language is a programming language that encourages that *style*.
*** Example
How would you sum the list of integers from 1 to 100?

Using a functional style, you might call a function to create the list, and then apply another function to sum the elements of that list.

Using an imperative style, you might create a couple variables (like step and total) and then use a loop to step one variable from 1 to 100 while keeping a running total in another variable.
** pattern matching and guards
Guards are something I haven't used much. I wasn't 100% comfortable with how they interacted with pattern matching. I created this odd function to demonstrate their interaction:

foo [1, a, b] | a > b     = True
              | otherwise = False
foo [2, a, b] | a < b     = True
              | otherwise = False
foo _ = False
** list comprehensions
List comprehensions are something I haven't used much. Here is a good example:

pythagoreanTriples n = [ (a, b, c) | a <- [1..n], b <- [a..n], c <- [b..n], a^2 + b^2 == c^2 ]

a <- [1..n] is an example of a generator.

a^2 + b^2 == c^2 is an example of a guard.

Note that generator variables can be used in later generators and guards.

The generators behave like nested loops, with the latter generators "iterating faster" than the earlier generators.
